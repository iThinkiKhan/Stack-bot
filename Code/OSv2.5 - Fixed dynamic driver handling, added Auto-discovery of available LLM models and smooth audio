#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "Audio.h" 
#include <TFT_eSPI.h>
#include <ESP32Servo.h>
#include <driver/i2s.h>
#include "Secrets.h"

// ==============================
//      PROJECT: FRANKEN-CHAN ("FRANK")
// ==============================

// --- HARDWARE ---
#define I2S_BCLK      4 
#define I2S_LRC       5 
#define I2S_DOUT      6  
#define I2S_DIN       7  
#define SERVO_PIN_X   1 
#define SERVO_PIN_Y   2  
#define SCREEN_RST    21 

// --- GLOBALS ---
Audio *audio = NULL; 
TFT_eSPI tft = TFT_eSPI(); 
Servo servoX;
Servo servoY;

#define I2S_PORT I2S_NUM_0
#define BUFFER_LEN 512
int16_t sBuffer[BUFFER_LEN];

// --- STATE ---
String lastStatus = ""; 
unsigned long lastServoMove = 0;
bool inSpeakerMode = false;
unsigned long micCooldown = 0;

// --- THREADING ---
TaskHandle_t aiTaskHandle = NULL;
bool aiRequestPending = false;     
bool aiResponseReady = false;      
String globalResponse = "";        

// --- MEMORY ---
// We move these to PSRAM if available automatically by the OS allocator
DynamicJsonDocument chatDoc(4096); 
DynamicJsonDocument responseDoc(8192);

// --- GEMINI CONFIG ---
String currentModel = "models/gemini-1.5-flash"; // Default backup

// ==============================
//      HELPER: SMART MODEL SELECTOR 
// ==============================
void findValidModel() {
//Unable to decode audio files
    Serial.println("--- SEARCHING FOR BEST TEXT MODEL ---");
    if(WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin("https://generativelanguage.googleapis.com/v1beta/models?key=" + String(GEMINI_API_KEY));
        int httpCode = http.GET();
        
        if (httpCode > 0) {
            String response = http.getString();
            
            int searchIndex = 0;
            // Reset to a safe default
            currentModel = "models/gemini-1.5-flash"; 

            while (true) {
                int nameStart = response.indexOf("\"name\": \"", searchIndex);
                if (nameStart == -1) break; 
                
                nameStart += 9; 
                int nameEnd = response.indexOf("\"", nameStart);
                String modelName = response.substring(nameStart, nameEnd);
                
                // --- NEW LOGIC: AVOID TTS, FIND FASTEST TEXT ---
                
                // Rule 1: skip any model with "tts" or "image" or "vision"
                // We strictly want text-generation models.
                if (modelName.indexOf("tts") != -1 || 
                    modelName.indexOf("image") != -1 || 
                    modelName.indexOf("vision") != -1) {
                    searchIndex = nameEnd;
                    continue;
                }

                // Priority 1: Gemini 2.0 Flash (The new speed king)
                if (modelName.indexOf("gemini-2.0-flash") != -1 && modelName.indexOf("exp") == -1) {
                    currentModel = modelName;
                    Serial.print(">>> UPGRADE (2.0 Flash): "); Serial.println(currentModel);
                }
                // Priority 2: Gemini 1.5 Flash (Reliable backup)
                else if (modelName.indexOf("gemini-1.5-flash") != -1 && currentModel.indexOf("2.0") == -1) {
                     currentModel = modelName;
                     // Silent update
                }
                
                searchIndex = nameEnd;
            }
            Serial.print(">>> FINAL SELECTION: "); Serial.println(currentModel);
        } else {
            Serial.printf("ListModels Failed: %d\n", httpCode);
        }
        http.end();
    }
    Serial.println("----------------------------------");
}

// ==============================
//      DRIVER MANAGEMENT
// ==============================
void enterMicMode() {
    if (!inSpeakerMode) return; 

    if (audio != NULL) {
        delete audio;
        audio = NULL;
    } else {
        i2s_driver_uninstall(I2S_PORT);
    }

    pinMode(I2S_DOUT, OUTPUT);
    digitalWrite(I2S_DOUT, LOW); 

    i2s_config_t i2s_config = {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = 16000,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 4,
        .dma_buf_len = 512,
        .use_apll = false,
        .tx_desc_auto_clear = false,
        .fixed_mclk = 0
    };
    i2s_pin_config_t pin_config = {
        .bck_io_num = I2S_BCLK,
        .ws_io_num = I2S_LRC,
        .data_out_num = -1,
        .data_in_num = I2S_DIN
    };
    
    i2s_driver_install(I2S_PORT, &i2s_config, 0, NULL);
    i2s_set_pin(I2S_PORT, &pin_config);
    i2s_zero_dma_buffer(I2S_PORT);
    
    inSpeakerMode = false;
    micCooldown = millis() + 1000; 
    Serial.println("--- Mic Mode Active ---");
}

void enterSpeakerMode() {
    if (inSpeakerMode) return; 

    i2s_driver_uninstall(I2S_PORT);
    
    audio = new Audio();
    audio->setPinout(I2S_BCLK, I2S_LRC, I2S_DOUT);
    audio->setVolume(18);     
    audio->forceMono(true);   
    
    // --- PSRAM BUFFERING (The "Anti-Chop" Fix) ---
    // If PSRAM is active, we can afford a HUGE buffer.
    // Default is usually ~6KB. We are asking for 100KB.
    if(psramFound()){
        // audio->setBufsize(InputBuffer, OutputBuffer);
        // We set input buffer to 100KB to absorb network jitter
        audio->setBufsize(100 * 1024, -1); 
        Serial.println("Audio Buffer: 100KB (PSRAM)");
    } else {
        Serial.println("Audio Buffer: Default (No PSRAM)");
    }
    
    inSpeakerMode = true;
    Serial.println("--- Speaker Mode Active ---");
}

// ==============================
//      UI 
// ==============================
void drawFace(String status, uint16_t color) {
    if (status == lastStatus) return;
    lastStatus = status;

    tft.fillScreen(TFT_BLACK);
    
    int w = tft.width();
    int h = tft.height();
    int eyeRadius = w / 10;
    int eyeY = h / 3;
    int leftEyeX = w / 4;
    int rightEyeX = (w * 3) / 4;
    int mouthY = (h * 2) / 3;

    tft.setTextColor(color, TFT_BLACK);
    tft.setTextSize(2);
    tft.setTextDatum(MC_DATUM);
    tft.drawString(status, w / 2, h - 30);

    if(status == "LISTENING" || status == "ONLINE" || status == "BOOTING...") {
        tft.fillCircle(leftEyeX, eyeY, eyeRadius, TFT_GREEN);
        tft.fillCircle(rightEyeX, eyeY, eyeRadius, TFT_GREEN);
        tft.fillCircle(w/2, mouthY, 40, TFT_GREEN);
        tft.fillCircle(w/2, mouthY - 5, 40, TFT_BLACK); 
    } 
    else if (status == "THINKING") {
        tft.fillCircle(leftEyeX, eyeY, eyeRadius, TFT_BLUE);
        tft.fillCircle(rightEyeX, eyeY, eyeRadius, TFT_BLUE);
        tft.fillRect(w/2 - 40, mouthY, 80, 10, TFT_BLUE);
    } 
    else {
        tft.fillCircle(leftEyeX, eyeY, eyeRadius, TFT_RED);
        tft.fillCircle(rightEyeX, eyeY, eyeRadius, TFT_RED);
        tft.fillCircle(w/2, mouthY + 10, 20, TFT_WHITE);
    }
}

// ==============================
//      TASK 1: BRAIN (AI)
// ==============================
void brainTask(void *pvParameters) {
    while (true) {
        if (aiRequestPending) {
            if(WiFi.status() == WL_CONNECTED) {
                HTTPClient http;
                http.setReuse(true); 
                http.setTimeout(15000); // 15s patience
                
                String url = "https://generativelanguage.googleapis.com/v1beta/" + currentModel + ":generateContent?key=" + GEMINI_API_KEY;
                http.begin(url);
                http.addHeader("Content-Type", "application/json");

                chatDoc.clear();
                responseDoc.clear();

                JsonArray contents = chatDoc.createNestedArray("contents");
                JsonObject contentObj = contents.createNestedObject();
                JsonArray parts = contentObj.createNestedArray("parts");
                JsonObject partObj = parts.createNestedObject();
                
                // Updated Prompt for Frank
                partObj["text"] = "You are Frank, a witty robot assistant. Answer in 1 short sentence. Prompt: I just snapped my fingers.";

                String jsonOutput;
                serializeJson(chatDoc, jsonOutput);
                int httpCode = http.POST(jsonOutput);
                
                if (httpCode > 0) {
                    String response = http.getString();
                    DeserializationError error = deserializeJson(responseDoc, response);
                    if (!error) {
                        if (responseDoc.containsKey("candidates")) {
                             globalResponse = responseDoc["candidates"][0]["content"]["parts"][0]["text"].as<String>();
                        } else if (responseDoc.containsKey("error")) {
                             String errMsg = responseDoc["error"]["message"].as<String>();
                             Serial.print("API ERROR: "); Serial.println(errMsg);
                             globalResponse = "My API Key is failing me.";
                        } else if (responseDoc.containsKey("promptFeedback")) {
                             globalResponse = "Safety Block.";
                        } else {
                             globalResponse = "I am confused.";
                        }
                    } else {
                        globalResponse = "JSON Parsing Failed.";
                    }
                } else {
                    Serial.printf("HTTP Error: %d\n", httpCode);
                    globalResponse = "Internet Error.";
                }
                http.end();
            } else {
                globalResponse = "No WiFi.";
            }
            aiRequestPending = false; 
            aiResponseReady = true;   
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

// ==============================
//      TASK 2: ROBOT (Logic)
// ==============================
void robotTask(void *pvParameters) {
    while(true) {
        
        // --- 1. HANDLE AI RESPONSE ---
        if (aiResponseReady) {
            aiResponseReady = false; 
            Serial.print("Frank Said: "); Serial.println(globalResponse);
            
            drawFace("SPEAKING", TFT_RED);
            String tts = "https://translate.google.com/translate_tts?ie=UTF-8&tl=en&client=tw-ob&q=" + globalResponse;
            if (audio) audio->connecttohost(tts.c_str());
        }

        // --- 2. SPEAKER MODE ---
        if (inSpeakerMode) {
            if (audio) audio->loop(); 
            
            if (audio && !audio->isRunning() && !aiRequestPending && !aiResponseReady) {
                 delay(100); 
                 enterMicMode();
                 drawFace("LISTENING", TFT_GREEN);
                 servoX.write(90); servoY.write(90);
            }
            
            if (millis() - lastServoMove > 200) { 
                int moveX = 90 + random(-10, 10);
                int moveY = 90 + random(-5, 5);
                servoX.write(moveX); servoY.write(moveY);
                lastServoMove = millis();
            }
            
            // NO DELAY HERE FOR SMOOTH AUDIO
            vTaskDelay(1 / portTICK_PERIOD_MS); 
        } 
        
        // --- 3. LISTENING MODE ---
        else {
            if (!aiRequestPending && millis() > micCooldown) {
                size_t bytesIn = 0;
                i2s_read(I2S_PORT, &sBuffer, 512, &bytesIn, 0);
                
                long sum = 0;
                int samples = bytesIn / 2;
                if(samples > 0) {
                    for (int i = 0; i < samples; i++) sum += abs(sBuffer[i]);
                    int volume = sum / samples;

                    if (volume > 500) { Serial.print("Volume: "); Serial.println(volume); }

                    if (volume > 3000) { 
                        Serial.println("Clap Detected! Waking Frank...");
                        enterSpeakerMode(); 
                        drawFace("THINKING", TFT_BLUE);
                        aiRequestPending = true;
                    }
                }
            }
            vTaskDelay(10 / portTICK_PERIOD_MS);
        }
    }
}

// ==============================
//      SETUP
// ==============================
void setup() {
    Serial.begin(115200);
    delay(1000);
    Serial.println("--- FRANK OS STARTING ---");
    
    // PSRAM CHECK
    if(psramFound()){
        Serial.printf("PSRAM Active! Total: %d bytes\n", ESP.getPsramSize());
    } else {
        Serial.println("WARNING: No PSRAM Detected!");
    }

    // Screen
    pinMode(SCREEN_RST, OUTPUT);
    digitalWrite(SCREEN_RST, HIGH); delay(50);
    digitalWrite(SCREEN_RST, LOW); delay(50);
    digitalWrite(SCREEN_RST, HIGH); delay(100);
    tft.init();
    tft.setRotation(1);
    tft.invertDisplay(false); 
    tft.setSwapBytes(true);
    drawFace("BOOTING...", TFT_WHITE);

    // Servos
    servoX.attach(SERVO_PIN_X);
    servoY.attach(SERVO_PIN_Y);
    servoX.write(90); servoY.write(90);

    // WiFi
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    while (WiFi.status() != WL_CONNECTED) delay(500);
    drawFace("ONLINE", TFT_GREEN);
    Serial.println("WiFi Connected");
    
    // Auto-Discovery
    findValidModel(); 
    
    // Tasks
    xTaskCreatePinnedToCore(brainTask, "BrainTask", 40960, NULL, 1, &aiTaskHandle, 1);
    xTaskCreatePinnedToCore(robotTask, "RobotTask", 20480, NULL, 1, NULL, 1);

    // Start
    inSpeakerMode = true; 
    enterMicMode();
}

// ==============================
//      EMPTY LOOP
// ==============================
void loop() {
    vTaskDelete(NULL); 
}
